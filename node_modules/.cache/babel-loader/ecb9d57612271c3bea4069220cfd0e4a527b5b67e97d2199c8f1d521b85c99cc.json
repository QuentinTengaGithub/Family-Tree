{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { createApp } from 'vue';\nimport Vuex from 'vuex';\nimport App from './App.vue';\nimport Home from './views/HomeView.vue';\nimport MemberList from './views/MemberList.vue';\nimport MemberTree from './views/MemberTree.vue';\nimport AddMember from './views/AddMember';\nimport SignUp from './views/SignUp.vue';\nimport SignIn from './views/SignIn.vue';\nimport { createRouter, createWebHistory } from 'vue-router';\nimport { db } from './firebaseConfig';\nimport { collection, doc, setDoc, getDocs, deleteDoc, updateDoc, getDoc } from 'firebase/firestore';\nimport { getAuth, onAuthStateChanged, signOut } from 'firebase/auth';\nimport AdminView from './views/AdminView.vue';\nimport ProfileView from './views/ProfileView.vue';\nconst routes = [{\n  path: '/',\n  component: Home,\n  meta: {\n    requiresAuth: true\n  }\n}, {\n  path: '/home',\n  component: Home,\n  meta: {\n    requiresAuth: true\n  }\n}, {\n  path: '/add-member',\n  component: AddMember,\n  meta: {\n    requiresAuth: true\n  }\n}, {\n  path: '/tree',\n  component: MemberTree,\n  meta: {\n    requiresAuth: true\n  }\n}, {\n  path: '/members',\n  component: MemberList,\n  meta: {\n    requiresAuth: true\n  }\n}, {\n  path: '/admin',\n  component: AdminView,\n  meta: {\n    requiresAuth: true,\n    requiresAdmin: true\n  }\n}, {\n  path: '/profile',\n  component: ProfileView,\n  meta: {\n    requiresAuth: true\n  }\n}, {\n  path: '/sign-up',\n  component: SignUp\n}, {\n  path: '/sign-in',\n  component: SignIn\n}];\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n});\nconst getCurrentUser = () => {\n  return new Promise((resolve, reject) => {\n    const removeListener = onAuthStateChanged(getAuth(), async user => {\n      removeListener();\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDocSnap = await getDoc(userDocRef);\n        if (userDocSnap.exists()) {\n          resolve({\n            ...user,\n            ...userDocSnap.data()\n          });\n        } else {\n          // If user exists in Auth but not Firestore, it's an invalid state.\n          // Sign them out and resolve to null so the router guard catches it.\n          await signOut(getAuth());\n          resolve(null);\n        }\n      } else {\n        resolve(null);\n      }\n    }, reject);\n  });\n};\nrouter.beforeEach(async (to, from, next) => {\n  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);\n  const requiresAdmin = to.matched.some(record => record.meta.requiresAdmin);\n  const user = await getCurrentUser();\n  store.commit('setUser', user);\n  if (requiresAuth && !user) {\n    next('/sign-in');\n  } else if (requiresAdmin && (!user || user.role !== 'admin')) {\n    alert(\"Access Denied: You do not have administrator privileges.\");\n    next(from.path || '/home'); // Redirect to previous page or home if admin access is denied\n  } else if (!requiresAuth && user) {\n    next('/home');\n  } else {\n    next();\n  }\n});\nconst store = new Vuex.Store({\n  state: {\n    members: [],\n    darkMode: false,\n    user: null\n  },\n  mutations: {\n    setMembers(state, members) {\n      state.members = members;\n    },\n    addMember(state, member) {\n      state.members.push(member);\n    },\n    deleteMember(state, memberName) {\n      state.members = state.members.filter(m => m.name !== memberName);\n    },\n    updateMember(state, updatedMember) {\n      const index = state.members.findIndex(m => m.name === updatedMember.name);\n      if (index !== -1) {\n        state.members[index] = {\n          ...state.members[index],\n          ...updatedMember\n        };\n      }\n    },\n    toggleDarkMode(state) {\n      state.darkMode = !state.darkMode;\n      localStorage.setItem('darkMode', state.darkMode);\n    },\n    setDarkMode(state, darkMode) {\n      state.darkMode = darkMode;\n    },\n    setUser(state, user) {\n      state.user = user;\n    }\n  },\n  actions: {\n    async fetchMembers({\n      commit,\n      state\n    }, paramUserId = null) {\n      const userId = paramUserId || (state.user ? state.user.uid : null);\n      if (!userId) {\n        commit('setMembers', []);\n        return;\n      }\n      const membersCol = collection(db, 'users', userId, 'members');\n      const memberSnapshot = await getDocs(membersCol);\n      let members = memberSnapshot.docs.map(doc => ({\n        ...doc.data(),\n        id: doc.id\n      }));\n      const memberMap = new Map(members.map(m => [m.id, m.name]));\n      const allMemberNames = new Set(members.map(m => m.name));\n      const getMemberName = identifier => {\n        if (!identifier) return '';\n        const nameFromId = memberMap.get(identifier);\n        if (nameFromId) return nameFromId;\n        if (allMemberNames.has(identifier)) return identifier;\n        return '';\n      };\n      members = members.map(member => {\n        const newMember = {\n          ...member\n        };\n        if (member.married) {\n          newMember.married = getMemberName(member.married);\n        }\n        if (member.siblings) {\n          newMember.siblings = member.siblings.map(getMemberName).filter(Boolean);\n        }\n        if (member.children) {\n          newMember.children = member.children.map(getMemberName).filter(Boolean);\n        }\n        return newMember;\n      });\n      console.log(\"Fetched and cleaned members:\", members);\n      commit('setMembers', members);\n    },\n    async addMember({\n      commit,\n      state\n    }, member) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      const memberData = {\n        ...member,\n        createdBy: userId\n      };\n      await setDoc(doc(db, \"users\", userId, \"members\", member.name), memberData);\n      commit('addMember', member);\n    },\n    async deleteMember({\n      commit,\n      state,\n      dispatch\n    }, memberName) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      await deleteDoc(doc(db, \"users\", userId, \"members\", memberName));\n      commit('deleteMember', memberName);\n      const membersToUpdate = state.members.filter(m => m.married === memberName || m.siblings.includes(memberName) || m.children.includes(memberName));\n      for (const member of membersToUpdate) {\n        const updatedMember = {\n          ...member\n        };\n        if (updatedMember.married === memberName) {\n          updatedMember.married = '';\n        }\n        if (updatedMember.siblings.includes(memberName)) {\n          updatedMember.siblings = updatedMember.siblings.filter(s => s !== memberName);\n        }\n        if (updatedMember.children.includes(memberName)) {\n          updatedMember.children = updatedMember.children.filter(c => c !== memberName);\n        }\n        dispatch('updateMember', updatedMember);\n      }\n    },\n    async updateMember({\n      commit,\n      state\n    }, member) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      const memberRef = doc(db, \"users\", userId, \"members\", member.name);\n      const dataToSave = {\n        ...member\n      };\n      delete dataToSave.toggleRelationship;\n      await updateDoc(memberRef, dataToSave);\n      commit('updateMember', member);\n    },\n    async setSiblings({\n      dispatch,\n      state\n    }, {\n      member,\n      selectedMember\n    }) {\n      if (!state.user) return;\n      const fullSiblingGroup = new Set([member.name, selectedMember.name, ...member.siblings, ...selectedMember.siblings]);\n      const membersToUpdate = state.members.filter(m => fullSiblingGroup.has(m.name));\n      for (const memberToUpdate of membersToUpdate) {\n        const newSiblings = [...fullSiblingGroup].filter(name => name !== memberToUpdate.name);\n        if (JSON.stringify(memberToUpdate.siblings) !== JSON.stringify(newSiblings)) {\n          dispatch('updateMember', {\n            ...memberToUpdate,\n            siblings: newSiblings\n          });\n        }\n      }\n    },\n    async updateMemberName({\n      dispatch,\n      state\n    }, {\n      oldName,\n      newName\n    }) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      const oldMemberRef = doc(db, \"users\", userId, \"members\", oldName);\n      const oldMemberSnap = await getDoc(oldMemberRef);\n      if (oldMemberSnap.exists()) {\n        const memberData = oldMemberSnap.data();\n        memberData.name = newName;\n        await setDoc(doc(db, \"users\", userId, \"members\", newName), memberData);\n        await deleteDoc(oldMemberRef);\n        const membersCol = collection(db, \"users\", userId, \"members\");\n        const memberSnapshot = await getDocs(membersCol);\n        const allMembers = memberSnapshot.docs.map(doc => ({\n          ...doc.data(),\n          id: doc.id\n        }));\n        for (const member of allMembers) {\n          if (member.id === newName) continue;\n          let needsUpdate = false;\n          const updatedData = {\n            ...member\n          };\n          delete updatedData.id;\n          if (updatedData.married === oldName) {\n            updatedData.married = newName;\n            needsUpdate = true;\n          }\n          if (updatedData.siblings && updatedData.siblings.includes(oldName)) {\n            updatedData.siblings = updatedData.siblings.map(s => s === oldName ? newName : s);\n            needsUpdate = true;\n          }\n          if (updatedData.children && updatedData.children.includes(oldName)) {\n            updatedData.children = updatedData.children.map(c => c === oldName ? newName : c);\n            needsUpdate = true;\n          }\n          if (needsUpdate) {\n            const memberToUpdateRef = doc(db, \"users\", userId, \"members\", member.id);\n            await updateDoc(memberToUpdateRef, updatedData);\n          }\n        }\n        dispatch('fetchMembers');\n      }\n    },\n    async migrateData({\n      dispatch,\n      state\n    }) {\n      if (!state.user) {\n        alert(\"You must be logged in to migrate data.\");\n        return;\n      }\n      const userId = state.user.uid;\n      const confirmation = confirm(\"This will migrate your Firestore data. It will delete and recreate documents to use names as IDs. This is a sensitive operation. Are you sure you want to proceed?\");\n      if (!confirmation) {\n        return;\n      }\n      const membersCol = collection(db, 'users', userId, 'members');\n      const memberSnapshot = await getDocs(membersCol);\n      const allMembers = memberSnapshot.docs.map(doc => ({\n        ...doc.data(),\n        id: doc.id\n      }));\n      const membersToMigrate = allMembers.filter(m => m.id !== m.name);\n      if (membersToMigrate.length === 0) {\n        alert(\"No members to migrate.\");\n        return;\n      }\n      const idMap = new Map();\n      for (const memberToMigrate of membersToMigrate) {\n        const oldId = memberToMigrate.id;\n        const newId = memberToMigrate.name;\n        if (oldId !== newId) {\n          idMap.set(oldId, newId);\n        }\n      }\n\n      // Pass 1: Create new docs and delete old ones\n      for (const memberToMigrate of membersToMigrate) {\n        const oldId = memberToMigrate.id;\n        const newId = memberToMigrate.name;\n        console.log(`Migrating ${newId} from ${oldId}`);\n        const memberData = {\n          ...memberToMigrate,\n          createdBy: userId\n        };\n        delete memberData.id;\n        await setDoc(doc(db, \"users\", userId, \"members\", newId), memberData);\n        await deleteDoc(doc(db, \"users\", userId, \"members\", oldId));\n      }\n\n      // Pass 2: Update relationships\n      const newMemberSnapshot = await getDocs(membersCol);\n      const newAllMembers = newMemberSnapshot.docs.map(doc => ({\n        ...doc.data(),\n        id: doc.id\n      }));\n      for (const member of newAllMembers) {\n        let needsUpdate = false;\n        const memberData = {\n          ...member\n        };\n        delete memberData.id;\n        if (memberData.married && idMap.has(memberData.married)) {\n          memberData.married = idMap.get(memberData.married);\n          needsUpdate = true;\n        }\n        if (memberData.siblings && memberData.siblings.length > 0) {\n          const originalSiblings = [...memberData.siblings];\n          memberData.siblings = memberData.siblings.map(s => idMap.get(s) || s);\n          if (JSON.stringify(originalSiblings) !== JSON.stringify(memberData.siblings)) {\n            needsUpdate = true;\n          }\n        }\n        if (memberData.children && memberData.children.length > 0) {\n          const originalChildren = [...memberData.children];\n          memberData.children = memberData.children.map(c => idMap.get(c) || c);\n          if (JSON.stringify(originalChildren) !== JSON.stringify(memberData.children)) {\n            needsUpdate = true;\n          }\n        }\n        if (needsUpdate) {\n          console.log(`Updating relationships for ${member.name}`);\n          const memberRef = doc(db, \"users\", userId, \"members\", member.id);\n          await updateDoc(memberRef, memberData);\n        }\n      }\n      alert(\"Data migration completed!\");\n      dispatch('fetchMembers');\n    },\n    async unsetChildren({\n      dispatch,\n      state\n    }, {\n      member,\n      childName\n    }) {\n      if (!state.user) return;\n      const parent = state.members.find(m => m.name === member.name);\n      if (parent) {\n        const newChildren = parent.children.filter(c => c !== childName);\n        dispatch('updateMember', {\n          ...parent,\n          children: newChildren\n        });\n      }\n    },\n    async unsetSibling({\n      dispatch,\n      state\n    }, {\n      member,\n      siblingName\n    }) {\n      if (!state.user) return;\n      const member1 = state.members.find(m => m.name === member.name);\n      const member2 = state.members.find(m => m.name === siblingName);\n      if (member1) {\n        const newSiblings = member1.siblings.filter(s => s !== siblingName);\n        dispatch('updateMember', {\n          ...member1,\n          siblings: newSiblings\n        });\n      }\n      if (member2) {\n        const newSiblings = member2.siblings.filter(s => s !== member.name);\n        dispatch('updateMember', {\n          ...member2,\n          siblings: newSiblings\n        });\n      }\n    }\n  }\n});\nconst app = createApp(App);\napp.use(router);\napp.use(store);\nstore.dispatch('fetchMembers');\nstore.watch(state => state.darkMode, darkMode => {\n  if (darkMode) {\n    document.body.classList.add('dark');\n  } else {\n    document.body.classList.remove('dark');\n  }\n}, {\n  immediate: true\n});\napp.mount('#app');","map":{"version":3,"names":["createApp","Vuex","App","Home","MemberList","MemberTree","AddMember","SignUp","SignIn","createRouter","createWebHistory","db","collection","doc","setDoc","getDocs","deleteDoc","updateDoc","getDoc","getAuth","onAuthStateChanged","signOut","AdminView","ProfileView","routes","path","component","meta","requiresAuth","requiresAdmin","router","history","getCurrentUser","Promise","resolve","reject","removeListener","user","userDocRef","uid","userDocSnap","exists","data","beforeEach","to","from","next","matched","some","record","store","commit","role","alert","Store","state","members","darkMode","mutations","setMembers","addMember","member","push","deleteMember","memberName","filter","m","name","updateMember","updatedMember","index","findIndex","toggleDarkMode","localStorage","setItem","setDarkMode","setUser","actions","fetchMembers","paramUserId","userId","membersCol","memberSnapshot","docs","map","id","memberMap","Map","allMemberNames","Set","getMemberName","identifier","nameFromId","get","has","newMember","married","siblings","Boolean","children","console","log","memberData","createdBy","dispatch","membersToUpdate","includes","s","c","memberRef","dataToSave","toggleRelationship","setSiblings","selectedMember","fullSiblingGroup","memberToUpdate","newSiblings","JSON","stringify","updateMemberName","oldName","newName","oldMemberRef","oldMemberSnap","allMembers","needsUpdate","updatedData","memberToUpdateRef","migrateData","confirmation","confirm","membersToMigrate","length","idMap","memberToMigrate","oldId","newId","set","newMemberSnapshot","newAllMembers","originalSiblings","originalChildren","unsetChildren","childName","parent","find","newChildren","unsetSibling","siblingName","member1","member2","app","use","watch","document","body","classList","add","remove","immediate","mount"],"sources":["/Users/quentin/Family-Tree/src/main.js"],"sourcesContent":["import { createApp } from 'vue';\nimport Vuex from 'vuex';\nimport App from './App.vue';\nimport Home from './views/HomeView.vue';\nimport MemberList from './views/MemberList.vue';\nimport MemberTree from './views/MemberTree.vue';\nimport AddMember from './views/AddMember';\nimport SignUp from './views/SignUp.vue';\nimport SignIn from './views/SignIn.vue';\nimport { createRouter, createWebHistory } from 'vue-router';\nimport { db } from './firebaseConfig';\nimport { collection, doc, setDoc, getDocs, deleteDoc, updateDoc, getDoc } from 'firebase/firestore';\n\nimport { getAuth, onAuthStateChanged, signOut } from 'firebase/auth';\n\nimport AdminView from './views/AdminView.vue';\nimport ProfileView from './views/ProfileView.vue';\n\nconst routes = [\n  { path: '/', component: Home, meta: { requiresAuth: true } },\n  { path: '/home', component: Home, meta: { requiresAuth: true } },\n  { path: '/add-member', component: AddMember, meta: { requiresAuth: true } },\n  { path: '/tree', component: MemberTree, meta: { requiresAuth: true } },\n  { path: '/members', component: MemberList, meta: { requiresAuth: true } },\n  { path: '/admin', component: AdminView, meta: { requiresAuth: true, requiresAdmin: true } },\n  { path: '/profile', component: ProfileView, meta: { requiresAuth: true } },\n  { path: '/sign-up', component: SignUp },\n  { path: '/sign-in', component: SignIn }\n];\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n});\n\nconst getCurrentUser = () => {\n  return new Promise((resolve, reject) => {\n    const removeListener = onAuthStateChanged(\n      getAuth(),\n      async (user) => {\n        removeListener();\n        if (user) {\n          const userDocRef = doc(db, \"users\", user.uid);\n          const userDocSnap = await getDoc(userDocRef);\n          if (userDocSnap.exists()) {\n            resolve({ ...user, ...userDocSnap.data() });\n          } else {\n            // If user exists in Auth but not Firestore, it's an invalid state.\n            // Sign them out and resolve to null so the router guard catches it.\n            await signOut(getAuth());\n            resolve(null);\n          }\n        } else {\n          resolve(null);\n        }\n      },\n      reject\n    );\n  });\n};\n\nrouter.beforeEach(async (to, from, next) => {\n  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);\n  const requiresAdmin = to.matched.some(record => record.meta.requiresAdmin);\n  const user = await getCurrentUser();\n  store.commit('setUser', user);\n\n  if (requiresAuth && !user) {\n    next('/sign-in');\n  } else if (requiresAdmin && (!user || user.role !== 'admin')) {\n    alert(\"Access Denied: You do not have administrator privileges.\");\n    next(from.path || '/home'); // Redirect to previous page or home if admin access is denied\n  } else if (!requiresAuth && user) {\n    next('/home');\n  } else {\n    next();\n  }\n});\n\nconst store = new Vuex.Store({\n  state: {\n    members: [],\n    darkMode: false,\n    user: null\n  },\n  mutations: {\n    setMembers(state, members) {\n      state.members = members;\n    },\n    addMember(state, member) {\n      state.members.push(member);\n    },\n    deleteMember(state, memberName) {\n      state.members = state.members.filter(m => m.name !== memberName);\n    },\n    updateMember(state, updatedMember) {\n      const index = state.members.findIndex(m => m.name === updatedMember.name);\n      if (index !== -1) {\n        state.members[index] = { ...state.members[index], ...updatedMember };\n      }\n    },\n    toggleDarkMode(state) {\n      state.darkMode = !state.darkMode;\n      localStorage.setItem('darkMode', state.darkMode);\n    },\n    setDarkMode(state, darkMode) {\n      state.darkMode = darkMode;\n    },\n    setUser(state, user) {\n      state.user = user;\n    }\n  },\n  actions: {\n    async fetchMembers({ commit, state }, paramUserId = null) {\n      const userId = paramUserId || (state.user ? state.user.uid : null);\n      if (!userId) {\n        commit('setMembers', []);\n        return;\n      }\n      const membersCol = collection(db, 'users', userId, 'members');\n      const memberSnapshot = await getDocs(membersCol);\n      let members = memberSnapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }));\n      \n      const memberMap = new Map(members.map(m => [m.id, m.name]));\n      const allMemberNames = new Set(members.map(m => m.name));\n\n      const getMemberName = (identifier) => {\n          if (!identifier) return '';\n          const nameFromId = memberMap.get(identifier);\n          if (nameFromId) return nameFromId;\n          if (allMemberNames.has(identifier)) return identifier;\n          return ''; \n      };\n\n      members = members.map(member => {\n        const newMember = { ...member };\n        if (member.married) {\n          newMember.married = getMemberName(member.married);\n        }\n        if (member.siblings) {\n          newMember.siblings = member.siblings.map(getMemberName).filter(Boolean);\n        }\n        if (member.children) {\n          newMember.children = member.children.map(getMemberName).filter(Boolean);\n        }\n        return newMember;\n      });\n\n      console.log(\"Fetched and cleaned members:\", members);\n      commit('setMembers', members);\n    },\n    async addMember({ commit, state }, member) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      const memberData = { ...member, createdBy: userId };\n      await setDoc(doc(db, \"users\", userId, \"members\", member.name), memberData);\n      commit('addMember', member);\n    },\n    async deleteMember({ commit, state, dispatch }, memberName) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      await deleteDoc(doc(db, \"users\", userId, \"members\", memberName));\n      commit('deleteMember', memberName);\n\n      const membersToUpdate = state.members.filter(m => m.married === memberName || m.siblings.includes(memberName) || m.children.includes(memberName));\n\n      for (const member of membersToUpdate) {\n        const updatedMember = { ...member };\n        if (updatedMember.married === memberName) {\n          updatedMember.married = '';\n        }\n        if (updatedMember.siblings.includes(memberName)) {\n          updatedMember.siblings = updatedMember.siblings.filter(s => s !== memberName);\n        }\n        if (updatedMember.children.includes(memberName)) {\n          updatedMember.children = updatedMember.children.filter(c => c !== memberName);\n        }\n        dispatch('updateMember', updatedMember);\n      }\n    },\n    async updateMember({ commit, state }, member) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      const memberRef = doc(db, \"users\", userId, \"members\", member.name);\n      const dataToSave = { ...member };\n      delete dataToSave.toggleRelationship;\n      await updateDoc(memberRef, dataToSave);\n      commit('updateMember', member);\n    },\n    async setSiblings({ dispatch, state }, { member, selectedMember }) {\n      if (!state.user) return;\n      const fullSiblingGroup = new Set([\n        member.name,\n        selectedMember.name,\n        ...member.siblings,\n        ...selectedMember.siblings,\n      ]);\n\n      const membersToUpdate = state.members.filter(m => fullSiblingGroup.has(m.name));\n\n      for (const memberToUpdate of membersToUpdate) {\n        const newSiblings = [...fullSiblingGroup].filter(name => name !== memberToUpdate.name);\n        if (JSON.stringify(memberToUpdate.siblings) !== JSON.stringify(newSiblings)) {\n          dispatch('updateMember', { ...memberToUpdate, siblings: newSiblings });\n        }\n      }\n    },\n    async updateMemberName({ dispatch, state }, { oldName, newName }) {\n      if (!state.user) return;\n      const userId = state.user.uid;\n      const oldMemberRef = doc(db, \"users\", userId, \"members\", oldName);\n      const oldMemberSnap = await getDoc(oldMemberRef);\n\n      if (oldMemberSnap.exists()) {\n        const memberData = oldMemberSnap.data();\n        memberData.name = newName;\n\n        await setDoc(doc(db, \"users\", userId, \"members\", newName), memberData);\n        await deleteDoc(oldMemberRef);\n\n        const membersCol = collection(db, \"users\", userId, \"members\");\n        const memberSnapshot = await getDocs(membersCol);\n        const allMembers = memberSnapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }));\n\n        for (const member of allMembers) {\n          if (member.id === newName) continue;\n\n          let needsUpdate = false;\n          const updatedData = { ...member };\n          delete updatedData.id;\n\n          if (updatedData.married === oldName) {\n            updatedData.married = newName;\n            needsUpdate = true;\n          }\n          if (updatedData.siblings && updatedData.siblings.includes(oldName)) {\n            updatedData.siblings = updatedData.siblings.map(s => s === oldName ? newName : s);\n            needsUpdate = true;\n          }\n          if (updatedData.children && updatedData.children.includes(oldName)) {\n            updatedData.children = updatedData.children.map(c => c === oldName ? newName : c);\n            needsUpdate = true;\n          }\n\n          if (needsUpdate) {\n            const memberToUpdateRef = doc(db, \"users\", userId, \"members\", member.id);\n            await updateDoc(memberToUpdateRef, updatedData);\n          }\n        }\n\n        dispatch('fetchMembers');\n      }\n    },\n    async migrateData({ dispatch, state }) {\n        if (!state.user) {\n            alert(\"You must be logged in to migrate data.\");\n            return;\n        }\n        const userId = state.user.uid;\n        const confirmation = confirm(\"This will migrate your Firestore data. It will delete and recreate documents to use names as IDs. This is a sensitive operation. Are you sure you want to proceed?\");\n        if (!confirmation) {\n            return;\n        }\n\n        const membersCol = collection(db, 'users', userId, 'members');\n        const memberSnapshot = await getDocs(membersCol);\n        const allMembers = memberSnapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }));\n\n        const membersToMigrate = allMembers.filter(m => m.id !== m.name);\n\n        if (membersToMigrate.length === 0) {\n            alert(\"No members to migrate.\");\n            return;\n        }\n\n        const idMap = new Map();\n\n        for (const memberToMigrate of membersToMigrate) {\n            const oldId = memberToMigrate.id;\n            const newId = memberToMigrate.name;\n            if (oldId !== newId) {\n                idMap.set(oldId, newId);\n            }\n        }\n\n        // Pass 1: Create new docs and delete old ones\n        for (const memberToMigrate of membersToMigrate) {\n            const oldId = memberToMigrate.id;\n            const newId = memberToMigrate.name;\n\n            console.log(`Migrating ${newId} from ${oldId}`);\n            \n            const memberData = { ...memberToMigrate, createdBy: userId };\n            delete memberData.id;\n            await setDoc(doc(db, \"users\", userId, \"members\", newId), memberData);\n            await deleteDoc(doc(db, \"users\", userId, \"members\", oldId));\n        }\n\n        // Pass 2: Update relationships\n        const newMemberSnapshot = await getDocs(membersCol);\n        const newAllMembers = newMemberSnapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }));\n\n        for (const member of newAllMembers) {\n            let needsUpdate = false;\n            const memberData = { ...member };\n            delete memberData.id;\n\n            if (memberData.married && idMap.has(memberData.married)) {\n                memberData.married = idMap.get(memberData.married);\n                needsUpdate = true;\n            }\n            if (memberData.siblings && memberData.siblings.length > 0) {\n                const originalSiblings = [...memberData.siblings];\n                memberData.siblings = memberData.siblings.map(s => idMap.get(s) || s);\n                if (JSON.stringify(originalSiblings) !== JSON.stringify(memberData.siblings)) {\n                    needsUpdate = true;\n                }\n            }\n            if (memberData.children && memberData.children.length > 0) {\n                const originalChildren = [...memberData.children];\n                memberData.children = memberData.children.map(c => idMap.get(c) || c);\n                if (JSON.stringify(originalChildren) !== JSON.stringify(memberData.children)) {\n                    needsUpdate = true;\n                }\n            }\n\n            if (needsUpdate) {\n                console.log(`Updating relationships for ${member.name}`);\n                const memberRef = doc(db, \"users\", userId, \"members\", member.id);\n                await updateDoc(memberRef, memberData);\n            }\n        }\n\n        alert(\"Data migration completed!\");\n        dispatch('fetchMembers');\n    },\n    async unsetChildren({ dispatch, state }, { member, childName }) {\n        if (!state.user) return;\n        const parent = state.members.find(m => m.name === member.name);\n        if (parent) {\n            const newChildren = parent.children.filter(c => c !== childName);\n            dispatch('updateMember', { ...parent, children: newChildren });\n        }\n    },\n    async unsetSibling({ dispatch, state }, { member, siblingName }) {\n        if (!state.user) return;\n        const member1 = state.members.find(m => m.name === member.name);\n        const member2 = state.members.find(m => m.name === siblingName);\n\n        if (member1) {\n            const newSiblings = member1.siblings.filter(s => s !== siblingName);\n            dispatch('updateMember', { ...member1, siblings: newSiblings });\n        }\n        if (member2) {\n            const newSiblings = member2.siblings.filter(s => s !== member.name);\n            dispatch('updateMember', { ...member2, siblings: newSiblings });\n        }\n    }\n  }\n});\n\nconst app = createApp(App);\n\napp.use(router);\napp.use(store);\n\nstore.dispatch('fetchMembers');\n\nstore.watch(\n  (state) => state.darkMode,\n  (darkMode) => {\n    if (darkMode) {\n      document.body.classList.add('dark');\n    } else {\n      document.body.classList.remove('dark');\n    }\n  },\n  { immediate: true }\n);\n\napp.mount('#app');\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}